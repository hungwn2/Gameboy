/*
 * adc.c
 *
 *  Created on: Nov 14, 2025
 *      Author: henryhungwy
 */


#include "../inc/adc.h"


#define GPIOAEN (1U<<0)
#define ADC1EN (1U<<8)
#define ADC_CH1	(1U<<0)
#define DMA2EN (1U<<22)
#define ADC_CH0	(0)
#define ADC_CH1	(1)
#define ADC_SEQ_LEN_2 (0x01)
#define CR1_SCAN	(1U<<8)
#define CR2_DMA (1U<<8)
#define CR2_DDS	(1U<<9)
#define CR2_ADCON	(1U<<0)
#define CR2_CONT	(1U<<1)
#define CR2_SWSTART		(1U<<30)
#define SR_EOC		(1U<<1)
#define SR_OVR          (1U<<5)  // Overrun flag



//One Channel ADC
void adc_init(void){
	RCC->AHB1ENR |= GPIOAEN;
	RCC->AHB1ENR |= DMA2EN;
	RCC->APB2ENR |=ADC1EN;
	GPIOA->MODER |=(1U<<2);
	GPIOA->MODER |=(1U<<3);
	GPIOA->MODER |=(1U<<0);
	GPIOA->MODER |=(1U<<1);
	ADC1->SQR1 =ADC_SEQ_LEN_2;
	ADC1->SQR3|= (ADC_CH0<<0)|(ADC_CH1<<5);
	ADC1->CR2 |= CR2_ADCON;
    for(volatile int i=0; i<10000; i++){}

}



uint32_t adc_read(uint8_t channel){
    if(ADC1->SR & SR_OVR) {
        ADC1->SR &= ~SR_OVR;
    }
    ADC1->SQR3 &= ~(0x1F);
    ADC1->SQR3 |= channel;
    ADC1->CR2 |=CR2_SWSTART;
	while(!(ADC1->SR & SR_EOC)){}
	return (ADC1->DR);
}
